.. _nbayes2-broadcasting:

.. index:: ! broadcasting

ブロードキャスト
================

それでは，いよいよ本題のブロードキャストの説明に移ります．
ブロードキャストとは， :attr:`ndim` や :attr:`shape` が異なる入力配列の間で，これらの属性を自動的に統一する機能です．
:attr:`ndim` と :attr:`shape` を統一することで，それらの入力配列間で要素ごとの演算が可能になり，その統一された次元数と大きさの出力配列に演算結果を得ることができます．
この機能により，例えば，次元数や大きさの異なる配列 :obj:`a` ， :obj:`b` ，および :obj:`c` があったとき，これらの配列の要素ごとの和を，明示的に変換を指示しなくても ``a + b + c`` の形式で書けるようになります．

`公式サイトのブロードキャストの規則 <http://docs.scipy.org/doc/numpy/reference/ufuncs.html#broadcasting>`_ は次の四つです．

1. 次元数 :attr:`ndim` が最大の入力配列より次元数 :attr:`ndim` が小さい全ての入力配列は， :attr:`shape` の先頭に 1 を加えて次元数を揃える．
2. 出力配列の :attr:`shape` の各次元の大きさは，入力配列のその次元の大きさのうちの最大値になる．
3. 入力配列ある各次元の大きさが出力配列の対応する次元の大きさと一致するか，1 である場合には，その入力は計算で利用可能になる．
4. 入力配列のある次元の大きさが 1 であるとき，その最初の要素の値がその次元の全ての計算で利用される．

これらの規則のうち，第1規則は次元数の統一に関するもので，それ以外は要素間の対応付けに関するものです．
それぞれについて順に説明します．

.. _nbayes2-broadcasting-ndim:

次元数の統一
------------

第1規則は，出力配列 :attr:`ndim` の値を決定し， :attr:`ndim` に変更のあった入力配列の :attr:`shape` を変更する方法を定めます．
出力配列の :attr:`ndim` は，入力配列のうち最大のものになります．
例えば，0次元のスカラー，1次元のベクトル，そして2次元の行列の三つの入力配列が在った場合，出力配列の :attr:`ndim` はこれらの中で一番大きな 2 となります．

:attr:`ndim` を増やした入力配列では， :attr:`shape` の先頭，すなわち第0次元の位置に，大きさ 1 の次元を，必要な数だけ追加します．
入力配列が，次のスカラー :obj:`a` ，ベクトル :obj:`b` ，そして行列 :obj:`c` の三つであった場合，

.. code-block:: ipython

    In [38]: a = np.array(100)
    In [39]: a
    Out[39]: array(100)
    In [40]: b = np.array([10, 20, 30])
    In [41]: b
    Out[42]: array([10, 20, 30])
    In [43]: c = np.array([[1, 2, 3], [4, 5, 6]])
    In [44]: c
    Out[44]:
    array([[1, 2, 3],
           [4, 5, 6]])

:attr:`ndim` は全て 2 に統一され， :attr:`shape` は次のようになります．

.. csv-table::
    :header-rows: 1

    入力配列, 統一前 :attr:`shape`, 統一後 :attr:`shape`
    :obj:`a`, "``()``", "``(1, 1)``"
    :obj:`b`, "``(3,)``", "``(1, 3)``"
    :obj:`c`, "``(2, 3)``", "``(2, 3)``"

0次元の :obj:`a` では，大きさが全て 1 の :attr:`shape` となります．
1次元の :obj:`b` では，元の大きさ3の第0次元の前に，大きさ 1 の次元が挿入されます．
すなわち，統一後の :attr:`ndim` が 2 の行列になる場合には，ベクトルは横ベクトルとして扱われます．
2次元の :obj:`c` は， :attr:`ndim` は変更されていないので， :attr:`shape` も変更されません．
このように自動的に次元数を統一する機構が備わっていますが，コードが直感的に分からなくなることも多いです．
そのため，実用的には，後述の :ref:`nbayes2-distlearn` の例のように， :const:`np.newaxis` などを用いて明示的に次元数を統一してから利用することをお薦めします．

.. _nbayes2-broadcasting-match:

要素の対応付け
--------------

次元数を統一し， :attr:`shape` を修正した後，第2規則で出力配列の :attr:`shape` を決定し，第3規則で演算要素の対応付けが可能かどうかを判定し，第4規則で実際の演算でどの要素対応付けるかを決定します．

まず，第2規則により，入力配列の :attr:`shape` の同じ次元の配列の大きさを比較し，そのうち最大のものを出力配列のその次元の大きさとします．
例えば，上記の入力配列 :obj:`a` ， :obj:`b` ，および :obj:`c` の場合は次の図のようになります．

.. image:: ../Fig/broadcast-match1.*
    :width: 8.32 cm
    :align: center

青色の第0次元の大きさを比較すると :obj:`a` では 1， :obj:`b` も 1，そして :obj:`c` も 2 なので，これら三つのうちで最大の 2 が出力配列の第0次元の大きさとなります．
同様にオレンジ色の第1次元では， :obj:`c` の 3 が最大なので，出力配列の第1次元の大きさは 3 となります．
よって，出力配列の :attr:`shape` は ``(2, 3)`` となります．

3次元以上の配列についても同様です．
:attr:`shape` が ``(2, 1, 1)`` の配列 :obj:`d` と ``(1, 3, 5)`` の :obj:`e` があった場合には，次の図のように出力配列の :attr:`shape` は ``(2, 3, 5)`` となります．

.. image:: ../Fig/broadcast-match2.*
    :width: 8 cm
    :align: center

第3規則は，出力配列と各入力配列の :attr:`shape` を比較し，要素の対応付けが可能かどうかを判定するためのものです．
全ての入力配列の，全ての次元で，その大きさが 1 であるか，もしくはその次元の大きさが出力配列の対応する次元と等しい場合にブロードキャスト可能 (broadcastable) であるといい，要素の対応付けが可能となります．

.. index:: broadcastable

上記の :obj:`a` ， :obj:`b` ，および :obj:`c` の例では， :obj:`a` の :attr:`shape` は ``(1, 1)`` で，どの次元でも大きさが 1 なのでブロードキャスト可能です．
:obj:`b` の :attr:`shape` は ``(1, 3)`` で，出力配列の :attr:`shape` ``(2, 3)`` と比較すると， :obj:`b` の第0次元の大きさは 1 で条件を満たし，第1次元の 3 は出力配列の第1次元の大きさ 3 と等しいのでやはり条件を満たすためブロードキャスト可能です．
:obj:`c` の :attr:`shape` は出力配列のそれと同じであるためやはりブロードキャスト可能で，全ての入力配列がブロードキャスト可能なため，全体でもブロードキャスト可能となります．

同様に，配列 :obj:`d` と :obj:`e` の場合も， :obj:`e` の :attr:`shape` ``(2, 1, 1)``  は出力配列の :attr:`shape` ``(2, 3, 5)`` と第0次元は一致し，その他は 1 なのでブロードキャスト可能です．
:obj:`e` の :attr:`shape` ``(1, 3, 5)`` は第0次元は 1 で，その他は出力配列と一致するためブロードキャスト可能であり，全体でもブロードキャスト可能になります．

ブロードキャスト可能でない例としては，入力配列の :attr:`shape` が ``(1, 2, 5)`` で，出力配列の :attr:`shape` が ``(3, 3, 5)`` などの場合，第0次元と第2次元は条件を満たしますが，入力配列の第1次元の大きさは 2 であり，これは 1 でもなく，かつ出力配列の第1次元の大きさ 3 とも一致しないため条件を満たさず，ブロードキャスト可能ではありません．
:ref:`nbayes2-fit2-fitif-try` 節の例は， :obj:`y` の :attr:`shape` が ``(n_samples,)`` であるのに対し， :obj:`yi` の :attr:`shape` は ``(n_classes,)`` であり，出力配列の :attr:`shape` は一般に ``(n_samples,)`` となり， :obj:`yi` がブロードキャスト可能ではないため失敗しました．

最後の第4規則により，各入力配列の要素を対応付けます．
この要素の対応付けは，次元数統一後の入力配列の：attr:`shape` に基づいて，次のように行います：

* 入力配列のある次元の大きさが，出力配列のそれと一致している場合では，統合後の入力配列の：attr:`shape` のその次元の大きさはそのまま変わりません．
* 入力配列のある次元の大きさが 1 である場合では，その一つの要素を，その次元では全ての演算で利用し続けます．
