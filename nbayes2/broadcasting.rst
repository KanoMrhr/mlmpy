.. _nbayes2-broadcasting:

.. index:: ! broadcasting

ブロードキャスト
================

それでは，いよいよ本題のブロードキャストの説明に移ります．
ブロードキャストとは， :attr:`ndim` や :attr:`shape` が異なる入力配列の間で，これらの属性を自動的に統一する機能です．
:attr:`ndim` と :attr:`shape` を統一することで，それらの入力配列間で要素ごとの演算が可能になり，その統一された次元数と大きさの出力配列に演算結果を得ることができます．
この機能により，例えば，次元数や大きさの異なる配列 :obj:`a` ， :obj:`b` ，および :obj:`c` があったとき，これらの配列の要素ごとの和を，明示的に変換を指示しなくても ``a + b + c`` の形式で書けるようになります．

`公式サイトのブロードキャストの規則 <http://docs.scipy.org/doc/numpy/reference/ufuncs.html#broadcasting>`_ は次の四つです．

1. 次元数 :attr:`ndim` が最大の入力配列より次元数 :attr:`ndim` が小さい全ての入力配列は， :attr:`shape` の先頭に 1 を加えて次元数を揃える．
2. 出力配列の :attr:`shape` の各次元の大きさは，入力配列のその次元の大きさのうちの最大値になる．
3. 入力配列ある各次元の大きさが出力配列の対応する次元の大きさと一致するか，1 である場合には，その入力は計算で利用可能になる．
4. 入力配列のある次元の大きさが 1 であるとき，その最初の要素の値がその次元の全ての計算で利用される．

これらの規則のうち，第1規則は次元数の統一に関するもので，それ以外は要素間の対応付けに関するものです．
それぞれについて順に説明します．

.. _nbayes2-broadcasting-ndim:

次元数の統一
------------

第1規則は，出力配列 :attr:`ndim` の値を決定し， :attr:`ndim` に変更のあった入力配列の :attr:`shape` を変更する方法を定めます．
出力配列の :attr:`ndim` は，入力配列のうち最大のものになります．
例えば，0次元のスカラー，1次元のベクトル，そして2次元の行列の三つの入力配列が在った場合，出力配列の :attr:`ndim` はこれらの中で一番大きな 2 となります．

:attr:`ndim` を増やした入力配列では， :attr:`shape` の先頭，すなわち第0次元の位置に，大きさ 1 の次元を，必要な数だけ追加します．
入力配列が，次のスカラー :obj:`a` ，ベクトル :obj:`b` ，そして行列 :obj:`c` の三つであった場合，

.. code-block:: ipython

    In [38]: a = np.array(100)
    In [39]: a
    Out[39]: array(100)
    In [40]: b = np.array([10, 20, 30])
    In [41]: b
    Out[42]: array([10, 20, 30])
    In [43]: c = np.array([[1, 2, 3], [4, 5, 6]])
    In [44]: c
    Out[44]:
    array([[1, 2, 3],
           [4, 5, 6]])

:attr:`ndim` は全て 2 に統一され， :attr:`shape` は次のようになります．

.. csv-table::
    :header-rows: 1

    入力配列, 統一前 :attr:`shape`, 統一後 :attr:`shape`
    :obj:`a`, "``()``", "``(1, 1)``"
    :obj:`b`, "``(3,)``", "``(1, 3)``"
    :obj:`c`, "``(2, 3)``", "``(2, 3)``"

0次元の :obj:`a` では，大きさが全て 1 の :attr:`shape` となります．
1次元の :obj:`b` では，元の大きさ3の第0次元の前に，大きさ 1 の次元が挿入されます．
すなわち，統一後の :attr:`ndim` が 2 の行列になる場合には，ベクトルは横ベクトルとして扱われます．
2次元の :obj:`c` は， :attr:`ndim` は変更されていないので， :attr:`shape` も変更されません．
このように自動的に次元数を統一する機構が備わっていますが，コードが直感的に分からなくなることも多いです．
そのため，実用的には，後述の :ref:`nbayes2-distlearn` の例のように， :const:`np.newaxis` などを用いて明示的に次元数を統一してから利用することをお薦めします．

.. _nbayes2-broadcasting-match:

要素の対応付け
--------------

次元数を統一し， :attr:`shape` を修正した後，第2規則で出力配列の :attr:`shape` を決定し，第3規則で演算要素の対応付けが可能かどうかを判定し，第4規則で実際の演算でどの要素対応付けるかを決定します．

出力配列の :attr:`shape` の決定
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

まず，第2規則により，入力配列の :attr:`shape` の同じ次元の配列の大きさを比較し，そのうち最大のものを出力配列のその次元の大きさとします．
例えば，上記の入力配列 :obj:`a` ， :obj:`b` ，および :obj:`c` の場合は次の図のようになります．

.. image:: ../Fig/broadcast-match1.*
    :width: 8.32 cm
    :align: center

青色の第0次元の大きさを比較すると :obj:`a` では 1， :obj:`b` も 1，そして :obj:`c` も 2 なので，これら三つのうちで最大の 2 が出力配列の第0次元の大きさとなります．
同様にオレンジ色の第1次元では， :obj:`c` の 3 が最大なので，出力配列の第1次元の大きさは 3 となります．
よって，出力配列の :attr:`shape` は ``(2, 3)`` となります．

3次元以上の配列についても同様です．
:attr:`shape` が ``(2, 1, 1)`` の配列 :obj:`d` と ``(1, 3, 5)`` の :obj:`e` があった場合には，次の図のように出力配列の :attr:`shape` は ``(2, 3, 5)`` となります．

.. image:: ../Fig/broadcast-match2.*
    :width: 8 cm
    :align: center

.. index:: broadcastable

ブロードキャスト可能性の判定
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

第3規則は，出力配列と各入力配列の :attr:`shape` を比較し，要素の対応付けが可能かどうかを判定するためのものです．
全ての入力配列の，全ての次元で，その大きさが 1 であるか，もしくはその次元の大きさが出力配列の対応する次元と等しい場合にブロードキャスト可能 (broadcastable) であるといい，要素の対応付けが可能となります．

上記の :obj:`a` ， :obj:`b` ，および :obj:`c` の例では， :obj:`a` の :attr:`shape` は ``(1, 1)`` で，どの次元でも大きさが 1 なのでブロードキャスト可能です．
:obj:`b` の :attr:`shape` は ``(1, 3)`` で，出力配列の :attr:`shape` ``(2, 3)`` と比較すると， :obj:`b` の第0次元の大きさは 1 で条件を満たし，第1次元の 3 は出力配列の第1次元の大きさ 3 と等しいのでやはり条件を満たすためブロードキャスト可能です．
:obj:`c` の :attr:`shape` は出力配列のそれと同じであるためやはりブロードキャスト可能で，全ての入力配列がブロードキャスト可能なため，全体でもブロードキャスト可能となります．

同様に，配列 :obj:`d` と :obj:`e` の場合も， :obj:`e` の :attr:`shape` ``(2, 1, 1)``  は出力配列の :attr:`shape` ``(2, 3, 5)`` と第0次元は一致し，その他は 1 なのでブロードキャスト可能です．
:obj:`e` の :attr:`shape` ``(1, 3, 5)`` は第0次元は 1 で，その他は出力配列と一致するためブロードキャスト可能であり，全体でもブロードキャスト可能になります．

ブロードキャスト可能でない例としては，入力配列の :attr:`shape` が ``(1, 2, 5)`` で，出力配列の :attr:`shape` が ``(3, 3, 5)`` などの場合，第0次元と第2次元は条件を満たしますが，入力配列の第1次元の大きさは 2 であり，これは 1 でもなく，かつ出力配列の第1次元の大きさ 3 とも一致しないため条件を満たさず，ブロードキャスト可能ではありません．
:ref:`nbayes2-fit2-fitif-try` 節の例は， :obj:`y` の :attr:`shape` が ``(n_samples,)`` であるのに対し， :obj:`yi` の :attr:`shape` は ``(n_classes,)`` であり，出力配列の :attr:`shape` は一般に ``(n_samples,)`` となり， :obj:`yi` がブロードキャスト可能ではないため失敗しました．

ブロードキャストの実行
^^^^^^^^^^^^^^^^^^^^^^

最後の第4規則により，各入力配列の要素を対応付けます．
この要素の対応付けは，次元数統一後の入力配列の：attr:`shape` に基づいて，次のように行います：

* 入力配列のある次元の大きさが，出力配列のそれと一致している場合では，統合後の入力配列の：attr:`shape` のその次元の大きさはそのまま変わりません．
* 入力配列のある次元の大きさが 1 である場合では，その一つの要素を，その次元では全ての演算で利用し続けます．

後者の場合，一つの要素の値をその次元の全ての要素にブロードキャストして（拡散して）用いるため，この仕組みをブロードキャストと呼んでいます．

この規則について，上記の三つの配列 :obj:`a` ， :obj:`b` ，および :obj:`c` を例にとり，次の図を用いて説明します．

.. image:: ../Fig/broadcast-cast1.*
    :width: 8.8 cm
    :align: center

この図では，第0次元は行数，第1次元は列数に対応しています．
出力配列の :attr:`shape` は ``(2, 3)`` であるため，どの入力配列もこの :attr:`shape` に統一されます．
次元数統一後の :obj:`a` の :attr:`shape` は ``(1, 1)`` でしたが，これは図中の :obj:`a` の青色の箱で表示しています．
第0次元の大きさは 1 なので，1行目の値が2行目でも利用されます．
第1次元の大きさも 1 なので，1列目の値が2列目以降でも利用されます．
よって， :obj:`a` では， ``a[0, 0]`` の値が，演算で常に利用されます．
:obj:`b` では，第0次元の大きさは 1 なので，第1行目の値が第2行目でも利用されますが，第1次元の大きさは出力配列と同じ大きさなのでそれぞれの列の値が利用されます．
よって， :obj:`b` では，第0行目の値が第1行目でも利用されるようになります．
:obj:`c` は，第0次元と第1次元のどちらでも，その大きさは出力配列と等しいので，それぞれの要素の値がそのまま演算で利用できます．
このようにして，全ての入力配列の :attr:`shape` を統一すれば，あとは同じ位置の要素同士で，要素ごとの演算ができるようになります．

:obj:`d` と :obj:`e` の場合についても，次の図を用いて説明します．

.. image:: ../Fig/broadcast-cast2.*
    :width: 6.88 cm
    :align: center

この図では，第0次元は手前から奥に増加し，第1次元が行数，第2次元が列数に対応しています．
この例では，出力配列の :attr:`shape` は ``(2, 3, 5)`` でした．
次元数統一後の :obj:`d` の :attr:`shape` は ``(2, 1, 1)`` であるため，第0次元のみ要素の値をそのまま用い，第1次元と第2次元では ``d[:, 0, 0]`` の値を用いることになります．
すなわち，手前と奥の両方の配列で，左上の要素の値を用いて演算します．
:obj:`e` の :attr:`shape` は ``(1, 3, 5)`` であるため，今度は第0次元では手前の配列の値を奥の配列で利用し，他の次元ではその要素の値をそのまま用います．
すなわち，手前の配列を奥の配列にコピーして利用するような感じになります．
こうして，入力配列の :attr:`shape` を統一した後は，要素ごとの演算ができるようになります．

やや長くなりましたが，以上で，配列の :attr:`shape` を操作する方法と，形式的なブロードキャストの規則とを説明しました．
次の節では，いよいよ，ブロードキャストを利用して，分布の計算を実装します．
