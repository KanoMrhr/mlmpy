.. _nbayes2-distlearn:

.. index:: broadcasting

分布の学習の実装
================

前節で説明したブロードキャストの機能を用いると， :obj:`for` ループを用いなくても，複数の要素に対する演算をまとめて行うことができます．
この節では，その方法を，単純ベイズの学習でのクラスや特徴の分布の計算の実装を通じて説明します．

.. _nbayes2-distlearn-classlearn:

クラス分布の学習
----------------

:ref:`nbayes2-fit2-fitif` 節で紹介した，クラス分布の計算の比較演算を用いた次の実装を，ブロードキャストの機能を用いて実装します．

.. code-block:: python

    nY = np.zeros(n_classes, dtype=np.int)
    for yi in xrange(n_classes):
        for i in xrange(n_samples):
            if y[i] == yi:
                nY[yi] += 1

書き換えの一般的な手順
^^^^^^^^^^^^^^^^^^^^^^

:obj:`for` ループによる実装をブロードキャストを用いて書き換える手順について，多くの人が利用している方針は見当たりません．
そこで，ここでは著者が採用している手順を紹介します．

1. 出力配列の次元数を :obj:`for` ループの数とします．
2. 各 :obj:`for` ループのループ変数ごとに，出力配列の次元を割り当てます．
3. 各ループ変数に割り当てた次元の要素は，そのループ変数がループ中でとりうる全ての値であり，その他の次元の大きさは 1 であるような配列を生成します．
4. 計算に必要な配列の生成します．
5. 冗長な配列を整理統合します．
6. 要素ごとの演算をユニバーサル関数の機能を用いて実行します．
7. :func:`np.sum` などの集約演算を適用して，最終結果を得ます．

それでは，上記のコードを例として，これらの手順を具体的に説明します．

ループ変数の次元への割り当て
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

手順の段階1と2により，各ループを次元に割り当てます．
例題のコードでは， :obj:`for` ループは2重なので，出力配列の次元数を 2 とします．
ループ変数は外側の :obj:`yi` と内側の :obj:`i` の二つで，これらに次元を一つずつ割り当てます．
ここでは，第 0 次元に :obj:`i` を，第 1 次元に :obj:`yi` を割り当てておきます．
表にまとめると次のようになります．

.. csv-table::
    :stub-columns: 1

    次元, 0, 1
    ループ変数, :obj:`i` , :obj:`yi`
    大きさ, ``n_samples`` , ``n_classes``
    意味, 標本, クラス

ループ変数に対応する配列の生成
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

手順の段階3により，各ループ変数がループ内で取り得る全ての値を要素に含む配列を生成します．
これらの要素は，段階2で割り当てた次元に格納します．
まずループ変数 :obj:`i` に関するループを見ます．

.. code-block:: python

    for i in xrange(n_samples):

このループでループ変数 :obj:`i` は ``0`` から ``n_samples - 1`` までの整数をとります．
これらの値を含む配列は ``np.arange(n_samples)`` により生成できます．
次に，これらの値が，ループ変数 :obj:`i` に割り当てた次元 0 の要素になり，他の次元の大きさは 1 になるようにします．
これは，:ref:`nbayes2-shape` で紹介した :attr:`shape` の操作技法を用いて次のように実装できます．

.. code-block:: python

    ary_i = np.arange(n_samples)[:, np.newaxis]

第0次元の ``:`` により， ``np.arange(n_samples)`` の内容を第0次元に割り当て，第1次元には ``np.newaxis`` により大きさ 1 の次元を設定します．

ループ変数 :obj:`yi` についての次のループも同様に処理します．

.. code-block:: python

    for yi in xrange(n_classes):

この変数は ``0`` から ``n_classes - 1`` までの整数をとり，第1次元に割り当てられているので，この変数に対応する配列は次のようになります．

.. code-block:: python

    ary_yi = np.arange(n_classes)[np.newaxis, :]

第0次元には大きさ 1 の次元を設定し，第1次元の要素には ``np.arange(n_classes)`` の内容を割り当てています．

                axis=0)
